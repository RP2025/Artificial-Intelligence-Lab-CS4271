# -*- coding: utf-8 -*-
"""2021CSB029_AI_LAB_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qARKsCBIqNo-qE1KExdNyio2T8vwtbkl

# Artificial Intelligence Laboratory 2025 CS 4271
## Raksha Pahariya | 2021CSB029

## 01_WaterJug

In the realm of Artificial Intelligence, contemplate a problem involving two containers  of indeterminate capacity, referred to as jugs. One jug has a capacity of 3 units, while  the other holds up to 4 units. There is no markings or additional measuring instruments,  the objective is to develop a strategic approach to precisely fill the 4-unit jug with 2  units of water. The restriction stipulates the use of solely the aforementioned jugs,  excluding any supplementary tools. Both jugs initiate the scenario in an empty state.  The aim is to attain the desired water quantity in the 4-unit jug by executing a sequence  of permissible operations, including filling, emptying, and pouring water between the  jugs.

The challenge in this scenario involves crafting an algorithm:


a. Define the permissible operations carefully that includes filling, emptying, and  pouring water between the jugs.


b. Use both Depth First Search and Breadth First Search to systematically explore and determine the optimal sequence of moves for accomplishing the task while  adhering to the defined constraints. Also determine the total path count to reach  to the goal state.


c. The initial and the goal state of the jugs may be varied.
"""

from collections import deque

def is_valid_state(state, capacity1, capacity2):
    """
    Check if the given state is valid within the jug capacities.
    """
    x, y = state
    return 0 <= x <= capacity1 and 0 <= y <= capacity2

def generate_next_states(state, capacity1, capacity2):
    """
    Generate all possible next states from the current state.
    """
    x, y = state
    return [
        (capacity1, y),  # Fill jug1 completely
        (x, capacity2),  # Fill jug2 completely
        (0, y),          # Empty jug1
        (x, 0),          # Empty jug2
        (max(0, x - (capacity2 - y)), min(capacity2, x + y)),  # Pour jug1 -> jug2
        (min(capacity1, x + y), max(0, y - (capacity1 - x)))   # Pour jug2 -> jug1
    ]

def water_jug_solver(capacity1, capacity2, initial_state, goal_state, method="BFS"):
    """
    Solve the water jug problem using the specified method (BFS or DFS).

    Args:
        capacity1 (int): Capacity of the first jug.
        capacity2 (int): Capacity of the second jug.
        initial_state (tuple): Starting state, e.g., (0, 0).
        goal_state (tuple): Target state to reach, e.g., (0, 2).
        method (str): Method to use ("BFS" or "DFS").

    Returns:
        path (list): Sequence of states to reach the target.
        steps (int): Total number of steps to reach the target.
        total_paths (int): Total paths explored during the search.
    """
    visited = set()
    total_paths = 0

    if method == "BFS":
        queue = deque([(initial_state, [])])
        while queue:
            current_state, path = queue.popleft()

            if current_state in visited:
                continue
            visited.add(current_state)

            path = path + [current_state]

            # Check if the goal state is reached
            if current_state == goal_state:
                total_paths += 1
                return path, len(path) - 1, total_paths

            # Generate and explore next states
            for next_state in generate_next_states(current_state, capacity1, capacity2):
                if is_valid_state(next_state, capacity1, capacity2) and next_state not in visited:
                    queue.append((next_state, path))

    elif method == "DFS":
        stack = [(initial_state, [])]
        while stack:
            current_state, path = stack.pop()

            if current_state in visited:
                continue
            visited.add(current_state)

            path = path + [current_state]

            # Check if the goal state is reached
            if current_state == goal_state:
                total_paths += 1
                return path, len(path) - 1, total_paths

            # Generate and explore next states
            for next_state in generate_next_states(current_state, capacity1, capacity2):
                if is_valid_state(next_state, capacity1, capacity2) and next_state not in visited:
                    stack.append((next_state, path))

    return None, -1, 0

def print_solution(path, steps, total_paths, goal_state):
    """
    Print the solution details, including the path, total steps, and paths explored.
    """
    if path:
        print(f"Steps to achieve goal state {goal_state}:")
        for i, step in enumerate(path):
            print(f"Step {i}: Jug1 = {step[0]}, Jug2 = {step[1]}")
        print(f"Total steps: {steps}")
        print(f"Total paths explored: {total_paths}")
    else:
        print("No solution found.")

# Example Usage
if __name__ == "__main__":
    capacity1 = 3
    capacity2 = 4
    initial_state = (0, 0)
    goal_state = (0, 2)

    method = "BFS"  # or "DFS"
    path, steps, total_paths = water_jug_solver(capacity1, capacity2, initial_state, goal_state, method)
    print_solution(path, steps, total_paths, goal_state)

# Example Usage
if __name__ == "__main__":
    capacity1 = 3
    capacity2 = 4
    initial_state = (0, 0)
    goal_state = (0, 2)

    method = "DFS"
    path, steps, total_paths = water_jug_solver(capacity1, capacity2, initial_state, goal_state, method)
    print_solution(path, steps, total_paths, goal_state)

# Example Usage
if __name__ == "__main__":
    capacity1 = 3
    capacity2 = 4
    initial_state = (1, 0)
    goal_state = (0, 2)

    method = "DFS"
    path, steps, total_paths = water_jug_solver(capacity1, capacity2, initial_state, goal_state, method)
    print_solution(path, steps, total_paths, goal_state)

"""##02_GridPuzzle

Develop a comprehensive program that effectively addresses a puzzle problem. The  puzzle involves a 3x3 grid with eight numbered tiles and an empty space (Given in the  diagram). The task is to create a program that can systematically rearrange the tiles,  around the empty cells, to reach to the predefined goal state from the initial  configuration adhering to the constraints of permissible moves.


a. Use two different heuristic functions: one, the total count of the number of  misplaced cells to reach to the goal state, second, consider the Manhattan distance as a heuristic function to determine the distance to reach to the goal  state.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjQAAAD4CAYAAAD7PnzlAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAADJ0SURBVHhe7Z0JuE7V98e3zJEooRQSCQ1K+pUGNIoopTTJv4lImgcakCaNhtKoORRF8zyXSqU0KBkyVpSQKOP5n89yjl430yX3vvvu7+d5zvPeu98zv2ev/V1rr71PoSjGCSGEEEJ4zGbJpxBCCCGEt0jQCCGEEMJ7JGiEEEII4T0SNEIIIYTwHgkaIYQQQniPBI0QQgghvEeCRgghhBDeI0EjhBBCCO+RoBFCCCGE90jQCCGEEMJ7JGiEEEII4T16l5MQIkiWLl3qZP6EWDuFCxd2m23mR+xDgkYIERyImTJlytinEGLNXH311bb4gASNECI4lixZ4kqVKuVef/11t/322yelYbJgwQLXqFEj9+6779o9CZnp06e7Qw45xI0dO9YiE6HTpEkTd+aZZ7ru3bsnJdmNBI0QIjhSQfPdd9+5nXbaKSkNk7lz57patWq5cePGubJlyyalYTJx4kRXu3ZtE3lFixZNSsOlRo0arm3btmEImuXLl7tly5bZpxBi9RQqVMi8PXl82YMEzT9I0PyDBM2qBCVo/vrrL3fWWWeZccBohwy3kYX7EPq9AESu7sWK5wIhc8EFF7h99tlHz0aWIEHzDxI0/yBBsyq+CZqNSl1evHixe+WVV+wzdP788083YsQIjZpIIDeBxiJ0SDqljsyYMUPPhlgFno358+ebuAod6gY2FCdZ9WTF/Vi0aJHuRS7ZqAgNyn7nnXe2BKotttgiKQ2TH3/80e222252T4oUKZKUhgtezimnnOKuuuqqpCRMMNA1a9Z099xzj2vVqpU3wx8LOvkZoUHIvPnmm+66665z06ZNs9FWnTp1cu3atXMlSpTI8yhefkZouBfjx4+3UTT8JtSXXXbZxf4vX758nt+L/I7Q0BxzDwYPHuyGDRvmHn/8cbf11lsn3+Y9vkVouIEbzJw5c6IKFSrYZ+hMmDAhiitAtHjx4qQkbOJGIurRo0fyX7jEXqfVkdg4RcuWLUtKRX5DPaW+Um/zEp6BoUOHRnGjGR1zzDFR69ato8qVK0exqIm6du0azZ8/P1kz78gvO758+fLorbfeiurXrx+9+OKLVlfmzZsXxUIvatSoUTRlyhRbJy/JTzvOtY4aNSq65JJLoljERLGwi2bNmpXn9yAT3+y43EUhhMgDYnvrFi5c6J566ilb8MIfe+wxN2TIEIsW3Xnnne7TTz9N1i74MKCECARRocaNG9s9IFrVokULFwsLG0bOPQuJPfbYw1155ZUWGQnt2v8LCoSg4YdPl1Dh2knETRfdi39G4IV8L0R2MWXKFHfcccdZtwrdSyz77befO+ecc+xZpdsnlOeV+jlr1ixb6OJJrzsdTBDapIdcc7FixeyZKFeuXFIqcoP3goZKQMLl8OHD3e+//56UhgX34Oeff3bPPfecu+uuu9zTTz9tOT2hNuSzZ8+2RFzuBZ4weQo0FkLkJzRYderUcSeccMIqeXaUk4tIzsaWW25p/4cA94BIxKRJk9yDDz5oSbCInA8//NCVLl3aHXjggcHci0y4ZuXabRje3jUaa8K3d9xxhz34F154oTVkoYEBILHxyCOPtBkdScI944wzbLbL1157LTgvh1EjnTt3tntx7bXXurPPPtsddthh7quvvgpW4InsgcYqZyPNc4ntohFnYEEo0GiTCE00olevXu6KK66wbiYcMrqidtxxxyAFjdhwvJaBU6dOtYx0+l7JkA/RCycjvnfv3u6YY45xzz//vHvppZdchw4dLFrVrVs399tvvwXTkPMMMJqoefPmbsyYMe6zzz5zp59+uk1n/tBDDylKI7IO6ibTXjDqicY9pDlxECu77rqriZcddtjB3Xfffe60004z5xRhp4koRW7xVtBQGeiHPvzww61ShKrk58yZ4xo2bGjDHOmL33///d0111xjSXb0xzOkPhRoGIjGnHTSSa5ChQquatWqFq0h0fCnn36SoBFZBxHWDz74wM2cOdOdd955lj8REqkd33fffV2lSpUsUnXzzTdbXo3qq8gtBaKjrnjx4slf4bHVVltZnzzeTCrqSpYsaYIG748up1AiNETq6tWrt0p+AveC52PvvfeWxyeyCuolkVRyvZiThvlGQnPMcDRIiMYpYzLOQw891H388cfu+OOPt+9CsV3iv0GZR55DI86wx5yGEO+G8mrVqgUbvcIYEqFC5DDJnxLtRDbBhHZ9+vRxJ554ojvooIOCm5ATZ+vee+91kydPti5zcmbofmLYNjlvDGtXlEbkBln4AkBOwUIuyZdffmlh3O222y44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u+eeeyyiKNaNBI0QQoh8AzFDg00OYuvWrd3mm2+efBMO3IOmTZu69u3b20izOnXquFtuucWVK1fOugLpuhbrxmtBs3z5clO2zB1A/grzKSxbtiz5VogVhmLWrFmWx8LfQojsAjHz+OOPW85KgwYNghxUwaAaBlFwD8iX4R6Qf0ieV/369YPPUV1fvBU0KFZCc2eddZZNzdy5c2d38sknu08//VThOWEgYBC7LVu2dDfeeKMJYCFE9kCd/Omnn9zLL7/sLrvssmAn9kPEZA4YoH0jQZnEaNo3vYZh/fBW0Hz99deuTZs21lg999xz7umnn7bh4+3atXMffPCBGi9h0br+/fu7r776yiJ5itAIkV0wwqpHjx5mu8uXL69RgDG0XeTQMAXIueeem6+jnHzDy6eHH/yFF16wd27sv//+Fp6jIuy9994WphsxYoQar8DBw3nttdfcu+++KyMpRBaCw/Hkk0+6HXbYwRJgVU+dtWl33HGHO/XUU92HH35o0Zlnn31WvQ7ribdPENN1szBmPxUvCB1++NBfsBY6PA9MdHjvvfe6yy+/PPj30wiRjTAH0JdffukuvfRS61Kh3qa2PPPvkOBt52eeeaZ1wZ199tlu4cKF7qqrrgpy5NeG4KWgIfy2++67WxLwtddea5O4MbEdipaJiY477jip/YDhGbj99tvdiSeeaDNZ61kQIrugjl5yySU2mIOh2rzR+YorrjAnhEntXn31VdetWzc3fvz4oIQNtorJDbFbN910kzv66KPd9OnTra0T68ZbQXPUUUe5Ro0a2YPPTIYff/yxu++++1y/fv0sU159jmFCGPull15amQwsMSNE9kFOG400+W1Dhgyxt1uzYM9xTpktePDgwatE4EMCu8UIp5NOOsn+D/EebAjeWnvG5yNgjjzySPfRRx9Z48XU8gcffLAasYDBm3nzzTfd9ddfH+R8FkL4APab3JDRo0ebeEkXXhHCPCznn3++JcYy0Vyo9hynnFdAkBeqYdvrh9dPCv2uVatWdU2aNDFVT/cTI540CVGYkFDHO0eI3lWqVCkpFUJkG2nXCg125sKIHr7DGeH/UBpy8j9//fXXVZJ/acfee+89e8EvIk+sG28FDUmf5513nr2866mnnnLXXXed9ct26tTJvf/++xq2HRj83gzdZ+jnzjvv7KZMmeImT57sfv75ZzMS8+fPt+gNnwrfCpEdEIXIuYQG9ogEaVIoWrRo4UaNGuVmz55tXW7ffPONu/nmmxVtXk+8FDQ0XogYJtHjAUC9Ml6fJDKywpl7RI1WWPB7v/XWW+6hhx6yofzkUTGM/9hjjzWhO3ToUAtfP//888kWQohso0qVKpYsTB0OBUQcEWUiy0xBQjLwDTfcYH8zhLtChQpKo1hPvBU0I0eOtPAkPzYwVJvJmVC59MVK0IQFRoFREsOHD7dIzbBhw+wTcYt3Q64Vc17QPSmEyE4QNAzjPuCAA5KSMCBPhtnMn3nmGYvM9O7d2+aioX0LMWq1oXgr+3j3BXkzmX2ONFyHHnqoJZyJsMCDqVu3rk3QRZ8zC+KWKA1id9tttzWvj08ZCCFENoFNIiKDrWIhP1R2Kvd4KWj44Zs3b27dS0Rq0nwZJh9ixBOvP1CITgghhAgHL1t9lCuvWqc7geG55M7wNwnBDRs2tJkWpW4F4Okw+yYRPYlcIYQouHhr4QnLNWvWzIZpM5sir14ngeqcc86xBkyCRvAM7LTTTu7bb7+1JDs9E0IIUXDxVtDQOOF9kxNBVIbcCV5yVqxYsWQNIVbk1hCd4bmQoBFCiIKLYvBCCCGE8B4JGiGEEEJ4jwSNEEIIIbxHgkYIIYQQ3iNBI4QQQgjvkaARQgghhPdI0AghhBDCeyRohBBCCOE9EjRCCCGE8B4JGiGEEEJ4jwSNEEIIIbxHgkYIIYQQ3iNBI4QQQgjvkaARQgghhPdI0AghhBDCeyRohBBCCOE9EjRCCCGE8B4JGiGEEEJ4jwSNEEIIIbxHgkYIIYQQ3iNBI4QQQgjvkaARQgghhPdI0AghhBDCewpFMcnfuWbu3LmuVq1abty4ca5s2bJJaZhMnDjR1a5d2y1YsMAVLVo0KQ2XGjVquLZt27ru3bsnJWHC81C9enU3YMAA16pVK7fZZvIhsoElS5a4UqVKuS+++MJVq1YtKQ2TP//802zXd99950qXLp2UhsnkyZPdHnvs4WbPnu2KFCmSlIZL3bp13emnn+6NHZeg+Y+QoFkVCZoVSNBkJ6mgYSlWrFhSGiaLFi1yS5cutQa8ePHiSWmYLF682P3xxx9uq622Ul2NmTdvnuvatasETWhI0KyKBM0KJGiyk1TQ9OnTx1WsWDEpDZO//vrLdezY0d19992uZMmSSWmYzJw503Xp0sUNGjTIFS5cOCkNl06dOtkiQRMYEjSrIkGzAgma7CQVNGPHjrXfJ2TwwlM7vuWWWyalYTJp0iSz43TDyY47V7NmTXfaaad5Y8dlXYUQwVKoUCETmSEv3IN0Wd33IS26D6su3Auf2OgIDd5Nhw4dXIkSJZLSMPn999/dnXfe6a688kqFKmP69u1ryXWNGzdOSsKEPvm77rrLDRw4UBGaLCKN0JAIu9NOOyWlYZKNkXaaJZa8ri+KtK+Kb5H2jRY0jBAgTBn6j0/DNX36dLsfarScmzZtmjUYJNeFDMmWv/32m3vkkUckaLKI/BQ0JOHOmTPHLV++PCn5B5yhcuXK5WmicrYIGu7H33//7ebPn2/nRG7PbrvtlqcOYjYIGq6bbsDM54PRZ1tssUWeR0yCEzTKoVmBlP2qKIdmBcqhyU7yS9DQSL399tuWaMmzkdlA8V3lypXdM88847bffvukdNOTDXaca//2229dr169zAlq3ry51ZtddtklKEFDc4ytuO2228xJBkaf9e7d27Vu3TrPo/++2XFZVyGEyCNouJ977jkTLk2bNnXHHHOMLUcffbTbeuut3bbbbuu22WabZO0wQFy+9NJL7vjjj7duahpzBE2dOnWC6r5HzPz0009uyJAhlozLvahXr5478MADreteztC60R0SQog8gAZr1qxZFoEYOnSo5VbReLP07NnTuhQOOOCAoCK8y5Ytc19++aXr3Lmza9Gihbvgggvc5ptvbo23bwmpGwvPx2uvvWbCbtiwYfaMPPXUU+6+++4zkRva/dgQJGgKMFSQdBFC5D801O3bt7c8GSaxI1cGATNjxgybA6Vhw4ZBeeJTpkyxQSXly5d3F110kc2DE2LDjY1mdmIGDzBb8bvvvmuRKwbbcE8UnVk/vL1L9C/+8ssvFqLLufz888+WeBdiQ05Im6QyjOOECRPcZ599ZvciJPjdeT54DjKfCUaiCZFf0FBXqlTJupUyGyie148//tgGFJC/EQpEZ5588kk3fvx4y9Og8f7111+tnqb5I6GA3X755ZfdN998YxMctmnTxh1yyCFu9OjRNrBATun64a2gwQAQnv3f//63ctlnn31soc+RZL/QHgIqBYl955xzjrviiivcV199ZR5gaB4P9+H11193+++//8pnYr/99nP33nuvDIPIOmjYacyOPfZYV6ZMmaS04MOIphdffNHE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G84/FktR9erVo9gzimIxFM2YMSO65557otggRPXq1bPzSuEc/vzzT7sX63s+KRxrzpw5ud5OCLFpoU7Gzkx04oknRnXq1DGbgB349ddfo1mzZkUffvhh1KhRoygWGdE777xjduy/BNswffr06MADD4xiJ8/s0JrsBMf+4Ycfot133z3q2rVrFAsvWz92EKNYdEXbb7+9fZ9uzyd2FTuWW9vD+nPnzo2WLFmSlAhfUJfTWsADIHKx7bbbWkgT9V+qVCnzYHID+yHyERsH218K3UJ33323hVxT8E523HFH17p1a1emTJn19oiKFStm3k3p0qWTkjUTixM7Lp7NscceaxEjru300093d911178iO3hwsahzscHIVVgXj+r77783jyo32wkhNi3YM+zOueeeaxHoO+64wx1//PFmB8qXL++22WYbFztG1vVNpCYWOf95HcaObr311na8dRGLE3fjjTda1Pjyyy93lStXNrsciyGL8uSMenOuRKljJ9KudX1hO+zdbbfdlqsuf5EdSNCsAwRF2uWzOiFDZWGhIvBJt9LqKhD7YZ10QczEHpA19nT/sB3lmazuf0QC6/KZ83tIz3VtYMimTJli55B5roiiQw45xMLM6fmyDl1Q9HGn55m5TXrNnE/OcrraYm/K/fzzzyuPlXnOmduu7lqEEJsG6mOfPn3cCy+84M4//3zrQs90tgB7t/3227tLLrlktY17pj3KrPuZZK6zpnq+Pg4iThjdYjmPVaRIEbfbbru5tm3b2t/AcX755Rfrypo/f/6/tuHv1Z0354aNGz58uHvmmWdM2OQ85/W5ZpF/FO4Rk/wtVgMPMA06D/mee+7pmjVrZhWHcozCRx99ZP23eDRffPGFe/XVVy3XBs8jFRc8+DTu7733nqtevbqVDR061PJUEBcICfqEd9hhB4uOUHnxLojQEHFBXLAP1n355ZfdyJEjTSTglXCsNIrD+eBRcdx27dr9y0BlMmTIEOuzZnuiRxgV9sMnUahq1arZfjB4HTt2tL51zmX8+PF2reXKlbPK/8knn7jXXnvNzp99bbXVVrYd61944YV2vpRz/QsWLLDoE2AQyOEhUXrChAkWXcL7Sq9FCLFpwHbNmDHDXXrppa5EiRKud+/eZq9WB3W5SpUqFhHZYostVtZP7BEiBzuFDZw7d67ZI2xj5jrUefIGiZRMnjzZ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)
"""

import heapq
import copy


class Puzzle:
    def __init__(self, goal):
        self.goal = goal

    def find_empty(self, board):
        """
        Find the position of the empty space (0) in the puzzle.
        """
        for i, row in enumerate(board):
            for j, val in enumerate(row):
                if val == 0:
                    return i, j

    def move(self, board, x, y, new_x, new_y):
        """
        Move the empty space (0) to a new position.
        """
        new_board = copy.deepcopy(board)
        new_board[x][y], new_board[new_x][new_y] = new_board[new_x][new_y], new_board[x][y]
        return new_board

    def get_neighbors(self, board):
        """
        Generate all possible moves (neighbors) for a given board.
        """
        x, y = self.find_empty(board)
        neighbors = []
        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
        for dx, dy in moves:
            new_x, new_y = x + dx, y + dy
            if 0 <= new_x < 3 and 0 <= new_y < 3:
                neighbors.append(self.move(board, x, y, new_x, new_y))
        return neighbors

    def is_goal(self, board):
        """
        Check if the given board is the goal state.
        """
        return board == self.goal


def a_star_solver(initial_state, goal_state, heuristic_function):
    """
    Solve the 8-puzzle problem using the A* algorithm.

    Args:
        initial_state (list): The starting state of the puzzle as a 2D list.
        goal_state (list): The goal state of the puzzle as a 2D list.
        heuristic_function (function): A heuristic function that takes a board
                                        and the goal state and returns a heuristic value.

    Returns:
        path (list): Sequence of states leading to the solution.
        steps (int): Number of steps in the solution.
        explored_states (int): Total number of states explored.
    """
    puzzle = Puzzle(goal_state)
    open_set = []
    heapq.heappush(open_set, (0, initial_state, []))  # (priority, board, path)
    closed_set = set()
    explored_states = 0  # Counter for explored states

    while open_set:
        cost, current_board, path = heapq.heappop(open_set)
        explored_states += 1  # Increment on every state expansion

        if tuple(map(tuple, current_board)) in closed_set:
            continue

        closed_set.add(tuple(map(tuple, current_board)))
        path = path + [current_board]

        if puzzle.is_goal(current_board):
            print(f"Solution found in {len(path) - 1} steps.")
            print(f"Total states explored: {explored_states}")
            print_solution(path)
            return path, len(path) - 1, explored_states

        for neighbor in puzzle.get_neighbors(current_board):
            if tuple(map(tuple, neighbor)) not in closed_set:
                g = len(path)  # Cost so far
                h = heuristic_function(neighbor, goal_state)  # Use the provided heuristic function
                heapq.heappush(open_set, (g + h, neighbor, path))

    print("No solution found.")
    return None, -1, explored_states


def print_solution(path):
    """
    Print the sequence of moves to reach the goal state.
    """
    for step, board in enumerate(path):
        print(f"Step {step}:")
        for row in board:
            print(" ".join(map(str, row)))
        print()


# Heuristic Functions
def misplaced_tiles(board, goal):
    """
    Calculate the number of misplaced tiles.
    """
    return sum(
        1 for i in range(3) for j in range(3) if board[i][j] != 0 and board[i][j] != goal[i][j]
    )


def manhattan_distance(board, goal):
    """
    Calculate the total Manhattan distance of tiles from their goal positions.
    """
    dist = 0
    for i in range(3):
        for j in range(3):
            val = board[i][j]
            if val != 0:
                goal_x, goal_y = [
                    (x, y) for x, row in enumerate(goal) for y, val_g in enumerate(row) if val_g == val
                ][0]
                dist += abs(i - goal_x) + abs(j - goal_y)
    return dist

if __name__ == "__main__":
    initial_state = [
        [1, 2, 3],
        [8, 0, 4],
        [7, 6, 5]
    ]
    goal_state = [
        [2, 8, 1],
        [4, 0, 3],
        [7, 6, 5]
    ]

    print("Solving with Manhattan Distance:")
    a_star_solver(initial_state, goal_state, manhattan_distance)

# Example usage 2
if __name__ == "__main__":
    initial_state = [
        [1, 2, 3],
        [8, 0, 4],
        [7, 6, 5]
    ]
    goal_state = [
        [2, 8, 1],
        [4, 0, 3],
        [7, 6, 5]
    ]

    print("Solving with Misplaced Tiles:")
    a_star_solver(initial_state, goal_state, misplaced_tiles)